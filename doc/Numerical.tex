\documentclass[10pt, openany]{book}
%
%  Packages to use
%
\usepackage{fancyhdr}
\usepackage{fancyvrb}
\usepackage{fancybox}
%
\usepackage{lastpage}
\usepackage{imakeidx}
%
\usepackage{amsmath}
\usepackage{amsfonts}
%
\usepackage{geometry}
\geometry{letterpaper}
%
\usepackage{url}
\usepackage{gensymb}
\usepackage{multicol}
\usepackage{xcolor}
%
\usepackage[pdf]{pstricks}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf}
\DeclareGraphicsRule{.pdf}{pdf}{.pdf}{}
%
% Rules to allow import of graphics files in EPS format
%
\usepackage{graphicx}
\DeclareGraphicsExtensions{.eps}
\DeclareGraphicsRule{.eps}{eps}{.eps}{}
%
%  Include the listings package
%
\usepackage{listings}
%
% Macro definitions
%
\newcommand{\operation}[1]{\textbf{\texttt{#1}}}
\newcommand{\package}[1]{\texttt{#1}}
\newcommand{\function}[1]{\texttt{#1}}
\newcommand{\constant}[1]{\emph{\texttt{#1}}}
\newcommand{\keyword}[1]{\texttt{#1}}
\newcommand{\datatype}[1]{\texttt{#1}}
\newcommand{\cli}[1]{\texttt{#1}}
\newcommand{\uvec}[1]{\textnormal{\bfseries{#1}}}
\newcommand{\comment}[1]{{\color{red}{#1}}}

\newcommand{\docname}{Users's Manual for \\ Basic Numerical Analysis Routines}
%
% Front Matter
%
\title{\docname}
\author{Brent Seidel \\ Phoenix, AZ}
\date{ \today }
%========================================================
%%% BEGIN DOCUMENT
\begin{document}
%
%  Header's and Footers
%
\fancypagestyle{plain}{
  \fancyhead[L]{}%
  \fancyhead[R]{}%
  \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}%
  \fancyfoot[L]{Ada Programming}
  \renewcommand{\headrulewidth}{0pt}%
  \renewcommand{\footrulewidth}{0.4pt}%
}
\fancypagestyle{myfancy}{
  \fancyhead[L]{\docname}%
  \fancyhead[R]{\leftmark}
  \fancyfoot[C]{Page \thepage\ of \pageref{LastPage}}%
  \fancyfoot[L]{Ada Programming}
  \renewcommand{\headrulewidth}{0.4pt}%
  \renewcommand{\footrulewidth}{0.4pt}%
}
\pagestyle{myfancy}
%
% Produce the front matter
%
\frontmatter
\maketitle
\begin{center}
This document is \copyright 2024 Brent Seidel.  All rights reserved.

\paragraph{}Note that this is a draft version and not the final version for publication.
\end{center}
\tableofcontents

\mainmatter
%========================================================
\chapter{Introduction}

Back in the 1980s when I was an undergraduate, I took a numerical analysis course and quite enjoyed it.  Then my first job out of college was working on a numerical analysis library for a small startup that went the way of most startups.  I was recently inspired to dig out my old textbook and try implementing some of the routines.  This collection includes some of those, plus others.

Note that some packages are for complex numbers and some are for real numbers.  At some point, they may be combined.  Most packages are generic.  The packages are:

\section{BBS.Numerical.complex}
This is an object oriented collection of complex number routines.  After writing this, I discovered \package{Ada.Numerics.Generic\_Complex\_Types}.  So this package is deprecated in favor of the Ada package.

\section{BBS.Numerical.derivative}
This is a generic package with a real type parameter.  It contains functions to compute the derivative of real valued functions with a single argument.

\section{BBS.Numerical.functions}
This is a generic package with a real type parameter.  It contains some functions that are used by other packages.

\section{BBS.Numerical.integration\_real}
This is a generic package with a real type parameter.  It contains functions to compute integrals of real valued functions with a single argument.

\section{BBS.Numerical.interpolation}
This is a generic package with a real type parameter.  It contains functions to interpolate a value between a set of data points.  The functions can also extrapolate (if using a value of $x$ outside of the range of the data points, however this is likely to be inaccurate.

\section{BBS.Numerical.ode}
This is a generic package with a real type parameter.  It contains functions to solve ordinary differential equations.

\section{BBS.Numerical.polynomial\_complex}
This is a generic package with a complex type parameter (from \package{Ada.Numerics.Generic\_Complex\_Types}.  It contains functions for polynomials.

\section{BBS.Numerical.plot}
This package defines the base class and interface for plotting.  You should not use the procedures from this package.

\section{BBS.Numerical.plot\_svg\_linear}
This package defines the class and procedures for plotting a linear-linear graph to a SVG file.

\section{BBS.Numerical.polynomial\_real}
This is a generic package with a real type parameter.  It contains functions for polynomials.

\section{BBS.Numerical.quaternion}
This is a generic package with a real type parameter.  It contains functions for quaternions.

\section{BBS.Numerical.random}
This is not a generic package.  It contains functions for generating pseudo-random numbers.

\section{BBS.Numerical.regression}
This is a generic package with a real type parameter.  It contains functions for performing regression analysis of data.

\section{BBS.Numerical.roots\_complex}
This is a generic package with a complex type parameter (from \package{Ada.Numerics.Generic\_Complex\_Types}.  It contains functions for finding zeros of functions.

\section{BBS.Numerical.roots\_real}
This is a generic package with a real type parameter.  It contains functions for finding zeros of functions.

\section{BBS.Numerical.statistics}
This is a generic package with a real type parameter.  It contains statistics related functions.

\section{BBS.Numerical.vector}
This is a generic package with a real type parameter.  It contains functions for vectors.

\section{License}
This project is licensed using the GNU General Public License V3.0.  Should you wish other licensing terms, contact the author.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

%========================================================
\chapter{How to Obtain}

This collection is currently available on GitHub at \url{https://github.com/BrentSeidel/Numerical}.

\section{Dependencies}
\subsection{Ada Libraries}
The following Ada libraries are used:
\begin{itemize}
  \item \package{Ada.Numerics}
  \item \package{Ada.Numerics.Generic\_Complex\_Types}
  \item \package{Ada.Numerics.Generic\_Complex\_Elementary\_Functions}
  \item \package{Ada.Numerics.Generic\_Elementary\_Functions}
  \item \package{Ada.Text\_IO} (used for debugging purposes)
\end{itemize}
\subsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada}.
Internal packages used within this library are:
\begin{itemize}
  \item \package{BBS.Numerical.functions}
  \item \package{BBS.Numerical.Integration\_real}
\end{itemize}

%========================================================
\chapter{Usage Instructions}
This is a library of routines intended to be used by some program.  To use these in your program, edit your *\keyword{.gpr} file to include a line to \keyword{with} the path to \keyword{BBS\_Numerical.gpr}.  Then in your Ada code \keyword{with} in the package(s) you need and use the routines.

%========================================================
\chapter{API Description}
%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.complex}
This package is deprecated in favor of the Ada package \package{Ada.Numerics.Generic\_Complex\_Types}.

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.derivative}
This is a generic package with a real type parameter, \datatype{F}.

It defines a function type \datatype{test\_func} as \datatype{access function (x : f'Base) return f'Base}.

WARNING:
The calculations here may involve adding small numbers to large numbers and taking the difference of two nearly equal numbers.
The world of computers is not the world of mathematics where numbers have infinite precision.  If you aren't careful, you can get into a situation where $(x + h) = x$, or $f(x) = f(x \pm h)$. For example assume that the float type has 6 digits.  Then, if $x$ is $1,000,000$ and $h$ is $1$, adding $x$ and $h$ is a wasted operation.

The functions are:
\subsection{Two Point Formulas}
Two point formula.  Use $h>0$ for forward-difference and $h<0$ for backward-difference.  Derivative calculated at point $x$.  While this is the basis for defining the derivative in calculus, it generally shouldn't be used.
\begin{lstlisting}
function pt2(f1 : test_func; x, h : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item \function{f1} - the function that you with to find the derivative of
  \item \function{x} - the point at which to calculate the derivative
  \item \function{h} - the step size
\end{itemize}

\subsection{Three Point Formulas}
Compute the derivative at $x$ using values at $x$, $x+h$, and $x+2h$.
\begin{lstlisting}
function pt3a(f1 : test_func; x, h : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item \function{f1} - the function that you with to find the derivative of
  \item \function{x} - the point at which to calculate the derivative
  \item \function{h} - the step size
\end{itemize}

Compute the derivative at $x$ using values at $x-h$ and $x+h$.
\begin{lstlisting}
function pt3b(f1 : test_func; x, h : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item \function{f1} - the function that you with to find the derivative of
  \item \function{x} - the point at which to calculate the derivative
  \item \function{h} - the step size
\end{itemize}

\subsection{Five Point Formulas}

Compute the derivative at $x$ using values at $x-2h$, $x-h$, $x+h$, and $x+2h$.
\begin{lstlisting}
function pt5a(f1 : test_func; x, h : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item \function{f1} - the function that you with to find the derivative of
  \item \function{x} - the point at which to calculate the derivative
  \item \function{h} - the step size
\end{itemize}

Compute the derivative at $x$ using values at $x$, $x+h$, $x+2h$, $x+3h$, and $x+4h$.
\begin{lstlisting}
function pt5b(f1 : test_func; x, h : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item \function{f1} - the function that you with to find the derivative of
  \item \function{x} - the point at which to calculate the derivative
  \item \function{h} - the step size
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.functions}
This is a generic package with a real type parameter, \datatype{F}.  Its primary purpose is to contain functions that are used by other packages in this library.  They may also be useful to the end user.

\subsection{Gamma Function Related}
Some of the probability functions require computing $\Gamma(\frac{n}{2})$.  Since $\Gamma(\frac{1}{2})=\sqrt{pi}$, $\Gamma(1) = 1$, and $\Gamma(a+1) = a*\Gamma(a)$, computing $\Gamma(\frac{n}{2})$, where $n$ is a positive integer is simpler than computing the full $\Gamma$ function.

Computes $\Gamma$ of $2n$.  Note that this will overflow for \datatype{Float} for $n>70$.
\begin{lstlisting}
function gamma2n(n : Positive) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $n$ - A positive integer representing twice the value for computing $\Gamma$.
  \item Returns the actual value.
\end{itemize}

To compute $\Gamma$ of $2n$ where $n>70$, logarithms can be used.  This returns the $log_e(\Gamma(n))$.
\begin{lstlisting}
function lngamma2n(n : Positive) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $n$ - A positive integer representing twice the value for computing $\Gamma$.
  \item Returns the natural log of the value.
\end{itemize}

\subsection{Factorial Related}
The factorial functions are similar to the $\Gamma$ functions.  Since the parameter is not divided by two in this case, overflow will occur for $n>35$.  Thus, as for $\Gamma$, there are two versions.  The first returns the actual value, the second returns the natural log of the value.
\begin{lstlisting}
function factorial(n : Natural) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $n$ - A natural integer representing.
  \item Returns the actual factorial value.
\end{itemize}
\begin{lstlisting}
function lnfact(n : Natural) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $n$ - A natural integer representing.
  \item Returns the natural log of the factorial value.
\end{itemize}

\subsection{Combinatorial Related}
The one function computes the binomial coefficients (aka N choose K).  By definition, this computes:
\begin{displaymath}
  \binom{n}{k} = \frac{n!}{k!(b-k)!}
\end{displaymath}
With some algebra, this becomes:
\begin{displaymath}
  \binom{n}{k} = \prod^k_{i=1}\frac{n+1-i}{i}
\end{displaymath}
 which is easier to compute.  The function is:
\begin{lstlisting}
function nChoosek(n, k : Natural) return f'Base
     with pre => (n >= k);
\end{lstlisting}
\begin{itemize}
  \item $n$ - The number of items.
  \item $k$ - The number of items to choose.
  \item Returns the binomial coefficient for $n$ and $k$.
  \item There is a restriction that $n\geq{}k$
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.integration\_real}
This is a generic package with a real type parameter, \datatype{F}.

It defines a function type \datatype{test\_func} as \datatype{access function (x : f'Base) return f'Base}.

This package contains routines to perform numerical integration of a function with one parameter.  Thus it computes an approximation to:
\begin{displaymath}
  y = \int_a^b f(x) dx
\end{displaymath}

\subsection{Trapezoid Rule}
This estimates the value of the integral using the composite trapezoid rule.
\begin{lstlisting}
function trapezoid(test : test_func; lower, upper : f'Base; steps : Positive)
         return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $test$ - The function to integrate.  It must match the datatype for \datatype{test\_func}.
  \item $lower$ - The lower bounds of the integration.
  \item $upper$ - The upper bounds of the integration.
  \item $steps$ - The number of steps to use.
\end{itemize}

\subsection{Simpson's Rule}
This estimates the value of the integral using the composite Simpson's rule.
\begin{lstlisting}
function simpson(test : test_func; lower, upper : f'Base; steps : Positive)
         return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $test$ - The function to integrate.  It must match the datatype for \datatype{test\_func}.
  \item $lower$ - The lower bounds of the integration.
  \item $upper$ - The upper bounds of the integration.
  \item $steps$ - The number of steps to use.
\end{itemize}

\subsection{Adaptive Simpson's}
This estimates the value of the integral using an adaptive version of Simpson's rule.  The interval is divided into two and each side is evaluated using the composite Simpson's with 1 and 2 steps.  The difference between the two evaluations is used as an error estimate.  If the error is two big, the interval is divided again and the function recurses until either the recursion limit is reached or the error is within limits.
\begin{lstlisting}
function adapt_simpson(test : test_func; lower, upper : f'Base;
                       tol : in out f'Base;
                       levels : Natural) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $test$ - The function to integrate.  It must match the datatype for \datatype{test\_func}.
  \item $lower$ - The lower bounds of the integration.
  \item $upper$ - The upper bounds of the integration.
  \item $tol$ - The desired error limit.  This also returns the estimated error.
  \item $levels$ - The allowed recursion depth.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.interpolation}
This is a generic package with a real type parameter, \datatype{F}.  It uses Lagrange polynomials to interpolate a value given a set of points.  The following data types are defined:
\begin{itemize}
  \item \datatype{point} - A record with $x$ and $y$ values of type \datatype{F}.
  \item \datatype{points} - A currently unused array of \datatype{point}.
\end{itemize}
Interpolation is most accurate within the range of the provided data points.  Outside of that range, it becomes extrapolation and may become increasingly inaccurate.  While higher order methods tend to be more accurate, there is also a potential for oscillations.  It is important to understand your data - if the data is linear or nearly so, using a 5th order method is probably a mistake.

\begin{lstlisting}
function lag2(p0, p1 : point; x : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item Interpolation with two points is linear interpolation.  The data is approximated as $y = ax+b$.
  \item $p0$ - The first known point.
  \item $p1$ - The second known point.
  \item $x$ - The location to interpolate.
\end{itemize}

\begin{lstlisting}
function lag3(p0, p1, p2 : point; x : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item Interpolation with three points is quadratic interpolation.  The data is approximated as $y = ax^2+bx+c$.
  \item $p0$ - The first known point.
  \item $p1$ - The second known point.
  \item $p2$ - The third known point.
  \item $x$ - The location to interpolate.
\end{itemize}

\begin{lstlisting}
function lag4(p0, p1, p2, p3 : point; x : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item Interpolation with four points is cubic interpolation.  The data is approximated as $y = ax^3+bx^2+cx+d$.
  \item $p0$ - The first known point.
  \item $p1$ - The second known point.
  \item $p2$ - The third known point.
  \item $p3$ - The fourth known point.
  \item $x$ - The location to interpolate.
\end{itemize}

\begin{lstlisting}
function lag5(p0, p1, p2, p3, p4 : point; x : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item Interpolation with five points is quartic interpolation.  The data is approximated as $y = ax^4+bx^3+cx^2+dx+e$.
  \item $p0$ - The first known point.
  \item $p1$ - The second known point.
  \item $p2$ - The third known point.
  \item $p3$ - The fourth known point.
  \item $p4$ - The fifth known point.
  \item $x$ - The location to interpolate.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.ode}
This is a generic package with a real type parameter, \datatype{F}.  It contains methods for numerically solving differential equations.

It defines the following datatypes:
\begin{itemize}
   \item \datatype{test\_func} as \datatype{access function (t, y : f'Base) return f'Base}
   \item \datatype{params} as \datatype{array (integer range <>) of f'Base}
   \item \datatype{sys\_func} as \datatype{access function (t : f'Base; y : params) return f'Base}
   \item \datatype{functs} as \datatype{array (integer range <>) of sys\_func}
\end{itemize}

The goal is to solve an equations:
\begin{displaymath}
  \frac{dy}{dt} = f(t, y)
\end{displaymath}
 for $a\leq t\leq b$, and $y(a) = \alpha$
 
\subsection{Historical}
Euler's method is mostly of historic interest.  It may be used if the function is expensive to evaluate and accuracy isn't very important.  It most case however, there are better methods.

\begin{lstlisting}
function euler(tf : test_func; start, initial, step : f'Base)
         return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $tf$ - The differential equation to solve.
  \item $start$ - The starting independent value for the step ($a$).
  \item $initial$ - The initial value of the differential equation ($\alpha$).
  \item $step$ - The step size.
\end{itemize}

\subsection{Runge-Kutta Methods}
The 4th order Runge-Kutta method is the workhorse differential equation solver.

\begin{lstlisting}
function rk4(tf : test_func; start, initial, step : f'Base)
         return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $tf$ - The differential equation to solve.
  \item $start$ - The starting independent value for the step ($a$).
  \item $initial$ - The initial value of the differential equation ($\alpha$).
  \item $step$ - The step size.
\end{itemize}

By combining a specific 4th order with specific 5th order Runge-Kutta method, one can produce an error estimate.  This is the Runge-Kutta-Fehlber method.  The error estimate can be used to adjust the step size, if needed to improve accuracy.

\begin{lstlisting}
function rkf(tf : test_func; start, initial, step : f'Base;
         tol : out f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $tf$ - The differential equation to solve.
  \item $start$ - The starting independent value for the step ($a$).
  \item $initial$ - The initial value of the differential equation ($\alpha$).
  \item $step$ - The step size.
  \item $tol$ - The error estimate as an output.
\end{itemize}

\subsection{Multistep Methods}
The multistep methods depends on the values at multiple previous positions rather than just an initial value.  Thus, generally another method (typically a Runge-Kutta) method is used to generate these values.

Fourth order Adams-Bashforth method.  This is a four step explicit method.

\begin{lstlisting}
function ab4(tf : test_func; start, step : f'Base; i0, i1, i2, i3 : f'Base)
         return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $tf$ - The differential equation to solve.
  \item $start$ - The starting independent value for the step ($a$).
  \item $step$ - The step size.
  \item $i0$ - The initial value of the differential equation ($\alpha$).
  \item $i1$ - The initial value of the differential equation ($\alpha_1$).
  \item $i2$ - The initial value of the differential equation ($\alpha_2$).
  \item $i3$ - The initial value of the differential equation ($\alpha_3$).
\end{itemize}

Fourth order Adams-Moulton method.  This is a three step implicit method.

\begin{lstlisting}
function am4(tf : test_func; start, step : f'Base; i0, i1, i2, i3 : f'Base)
         return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $tf$ - The differential equation to solve.
  \item $start$ - The starting independent value for the step ($a$).
  \item $step$ - The step size.
  \item $i0$ - The initial value of the differential equation ($\alpha$).
  \item $i1$ - The initial value of the differential equation ($\alpha_1$).
  \item $i2$ - The initial value of the differential equation ($\alpha_2$).
  \item $i3$ - The initial value of the differential equation ($\alpha_3$).
\end{itemize}

Fourth order Adams-Bashforth/Adams-Moutlton method.  This uses the Adams-Bashforth method to predict the final value and then uses the Adams-Moulton method to refine that value as a corrector method.

\begin{lstlisting}
function abam4(tf : test_func; start, step : f'Base; i0, i1, i2, i3 : f'Base)
         return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $tf$ - The differential equation to solve.
  \item $start$ - The starting independent value for the step ($a$).
  \item $step$ - The step size.
  \item $i0$ - The initial value of the differential equation ($\alpha$).
  \item $i1$ - The initial value of the differential equation ($\alpha_1$).
  \item $i2$ - The initial value of the differential equation ($\alpha_2$).
  \item $i3$ - The initial value of the differential equation ($\alpha_3$).
\end{itemize}

\subsection{Systems of Differential Equations}
The previous methods solve a single first order differential equation.  If you have a higher order equation or a system of coupled equations, then you need a method that works on systems of differential equations.  An nth order system of first order equations has the form:
\begin{align*}
  \frac{dy_1}{dt} &= f_1(t, y_1, ..., y_n) \\
  \frac{dy_2}{dt} &= f_2(t, y_1, ..., y_n) \\
  &\vdots\\
  \frac{dy_n}{dt} &= f_n(t, y_1, ..., y_n)
\end{align*}
with $a\leq t\leq b$, and initial conditions:
\begin{align*}
  y_1(a) &= \alpha_1 \\
  y_2(a) &= \alpha_2 \\
  &\vdots \\
  y_n(a) &= \alpha_n
\end{align*}

To solve higher order differential equations, they need to be transformed into a system of first order equations.

\begin{lstlisting}
function rk4s(tf : functs; start : f'Base; initial : params; step : f'Base)
         return params
      with pre => (tf'First = initial'First) and (tf'Last = initial'Last);
\end{lstlisting}
\begin{itemize}
  \item $tf$ - An array containing the system of differential equations to solve ($f_1 ... f_n$).
  \item $start$ - The starting independent value for the step ($a$).
  \item $initial$ - An array containing the initial values for the system of differential equation ($\alpha_1 ... \alpha_n$).
  \item $step$ - The step size.
  \item There is a restriction that the array bounds for $tf$ and $initial$ must be the same.
  \item The returned array has the same bounds as $tf$ and $initial$.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.plot}
This package defines some data types, a base class, and an interface for plotting graphs.  The type of graph and the medium are to be handled by sub-classes.

\subsection{Datatypes}
There are three datatype for use by the end user and two for subclass implementors.  The \datatype{point} datatype is a record consisting of $x$ and $y$ components as \datatype{Float}.  The \datatype{point\_list} datatype is an unconstrained array of \datatype{point} records.  The last user datatype is \datatype{glyph}.  This is an enumeration of the various glyphs that can be drawn to plot points.  The current glyphs are \datatype{glyph\_plus}, \datatype{glyph\_X}, \datatype{glyph\_asterisk}, \datatype{glyph\_box}, \datatype{glyph\_diamond}, and \datatype{glyph\_octagon}.  More glyphs may be added.

The two datatype for subclass implementors are \datatype{plot\_record} and \datatype{plot}, which is an access type for \datatype{plot\_record}.

\subsection{Common Interface}
A common interface is defined that all plotting implementations should support.  In addition, each plotting implementation will likely have some specific routines for initializing and terminating the plot.

The common routines are:
\begin{lstlisting}
procedure frame(self : in out plot_record; xTicks, yTicks : Natural;
                xLines , yLines : Boolean);
\end{lstlisting}
This draws the basic frame of a plot.  The parameters are:
\begin{itemize}
  \item $self$ - The plot being updated.
  \item $xTicks$ - The number of ticks to be drawn on the X-axis (or number of cycles for a log plot).
  \item $yTicks$ - The number of ticks to be drawn on the Y-axis (or number of cycles for a log plot).
  \item $xLines$ - Should be lines for the X-axis be draw as ticks or all the way across the plot?
  \item $yLines$ - Should be lines for the Y-axis be draw as ticks or all the way across the plot?
\end{itemize}
\begin{lstlisting}
procedure label(self : in out plot_record; xLabel, yLabel : String);
\end{lstlisting}
Draw the axis labels on the plot.
\begin{itemize}
  \item $self$ - The plot being updated.
  \item $xLabel$ - The label for the X-axis.
  \item $yLabel$ - The label for the Y-axis
\end{itemize}
\begin{lstlisting}
 procedure title(self : in out plot_record; title : String);
\end{lstlisting}
Draw the title on the plot.
\begin{itemize}
  \item $self$ - The plot being updated.
  \item $title$ - The title to add to the plot.
\end{itemize}
\begin{lstlisting}
procedure draw_line(self : in out plot_record; points : point_list;
                    color : String);
\end{lstlisting}
Draw a line on the plot through a list of points.
\begin{itemize}
  \item $self$ - The plot being updated.
  \item $points$ - An array of points to plot.
  \item $color$ - A string representing the color of the line.
\end{itemize}
\begin{lstlisting}
procedure draw_point(self : in out plot_record; p : point;
                     size : Positive; color : String);
\end{lstlisting}
Draw a single point on the plot as a circle.
\begin{itemize}
  \item $self$ - The plot being updated.
  \item $p$ - The point to plot.
  \item $size$ - The radius of the circle to draw.
  \item $color$ - A string representing the color of the circle.
\end{itemize}
\begin{lstlisting}
procedure draw_point(self : in out plot_record; points : point_list;
                     size : Positive; color : String);
\end{lstlisting}
Draw a set of points on a plot as circles.
\begin{itemize}
  \item $self$ - The plot being updated.
  \item $points$ - An array of points to plot.
  \item $size$ - The radius of the circles to draw.
  \item $color$ - A string representing the color of the circles.
\end{itemize}
\begin{lstlisting}
procedure draw_text(self : in out plot_record; p : point;
                    color, text : String);
\end{lstlisting}
Draw some text at a specified point on the plot.
\begin{itemize}
  \item $self$ - The plot being updated.
  \item $p$ - The location to draw the text.
  \item $color$ - A string representing the color of the text.
  \item $text$ - The text to draw.
\end{itemize}
\begin{lstlisting}
procedure draw_glyph(self : in out plot_record; p : point; g : glyph;
                     color : String);
\end{lstlisting}
Draw a single glyph at a specified point on the plot.
\begin{itemize}
  \item $self$ - The plot being updated.
  \item $p$ - The location of the glyph.
  \item $g$ - The glyph to draw.
  \item $color$ - A string representing the color of the glyph.
\end{itemize}
\begin{lstlisting}
procedure draw_glyph(self : in out plot_record; points : point_list;
                     g : glyph; color : String);
\end{lstlisting}
Draw a set of glyphs at a specified points on the plot.
\begin{itemize}
  \item $self$ - The plot being updated.
  \item $points$ - An array of points for the glyph locations.
  \item $g$ - The glyph to draw.
  \item $color$ - A string representing the color of the glyph.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.plot\_svg\_linear}
This package contains specific routines for drawing a plot with linear axis to a SVG format file.  In addition to the routines defined in \package{BBS.Numerical.plot}, it defines two additional routines.  For using the common interface, use a \datatype{BBS.Numerical.linear\_svg\_plot\_record} instead of the basic \datatype{BBS.Numerical.plot\_record}.
\begin{lstlisting}
procedure start_plot(self : in out linear_svg_plot_record; name : string;
                     xmin, xmax, ymin, ymax : float);
\end{lstlisting}
Starts a plot.  It opens the output file for the SVG plot and sets the plot's bounds.
\begin{itemize}
  \item $self$ - The plot being started.
  \item $name$ - The name of the file to open.
  \item $xmin$ - The smallest $X$ value on the plot.
  \item $xmax$ - The largest $X$ value on the plot.
  \item $ymin$ - The smallest $Y$ value on the plot.
  \item $ymax$ - The largest $Y$ value on the plot.
\end{itemize}
\begin{lstlisting}
procedure end_plot(self : in out linear_svg_plot_record);
\end{lstlisting}
This ends the plot and closes the plot file.  If the plot has not been started, the nothing happens.
\begin{itemize}
  \item $self$ - The plot being closed.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.polynomial\_complex}
This is a generic package with a complex package parameter, \datatype{cmplx}.  This parameter has datatypes \datatype{cmplx.Complex} and \datatype{cmplx.Real}.

The package defines the datatype \datatype{poly} as \datatype{array (Natural range  <>) of cmplx.Complex}, with a constraint that \datatype{poly'First} is equal to 0.  Polynomials are implemented as an array of coefficients where the index in the array represents the exponent of the independent variable.  The index range starts from 0 and extends to the order of the polynomial.  This package contains operations on polynomials with complex number coefficients and independent variable.

\subsection{Basic Operations}
The basic binary operations on polynomials, addition (`+'), subtraction (`-'), and multiplication (`*') are implemented and assigned to the operators.  Unary negation (`-') is implemented and assigned to the `-' operator.  Multiplication of a polynomial by a scalar is implemented and assigned to the `*' operator for both scalar first and scalar last.

Division is based on the \function{polydiv()} implementation of synthetic division in \cite{NR-C}.  It divides two polynomials and returns a remainder and quotient.
\begin{align*}
  \frac{u}{v} = q, r
\end{align*}
\begin{lstlisting}
procedure divide(u, v : poly; q : out poly; r : out poly)
      with pre => (q'Last >= (u'Last - v'Last)) and
                  (r'Last >= (v'Last - 1)) and
                  (u'Last >= v'Last);
\end{lstlisting}
\begin{itemize}
  \item $u$ - The numerator for division.
  \item $v$ - The denominator for division.
  \item $q$ - The quotient result of the division.
  \item $r$ - The remainder from the division.
  \item This is a procedure, thus nothing is returned.
\end{itemize}

\subsection{Other Operations}

Evaluate a polynomial at a specific value of the independent variable.
\begin{lstlisting}
function evaluate(p : poly; x : cmplx.Complex) return cmplx.Complex;
\end{lstlisting}
\begin{itemize}
  \item $p$ - The polynomial to evaluate.
  \item $x$ - The independent variable.
  \item Returns the value of the polynomial evaluated at $x$.
\end{itemize}

Eliminate any leading coefficients with a zero value.  For example $0x^3+x^2+3x+4$ gets trimmed to $x^2+3x+4$.
\begin{lstlisting}
function trim(p : poly) return poly
      with post => (trim'Result'Last <= p'Last);
\end{lstlisting}
\begin{itemize}
  \item $p$ - The polynomial to trim.
  \item Returns the trimmed polynomial of order equal to or less than the original polynomial.
\end{itemize}

Determine the order of a polynomial.  That is the maximum index with a non-zero value.
\begin{lstlisting}
function order(p : poly) return Natural;
\end{lstlisting}
\begin{itemize}
  \item $p$ - The polynomial to determine the order of.
  \item Returns the order of the polynomial.
\end{itemize}

\subsection{Utility}
For development or debugging purposes a simple print polynomial procedure is provided.

\begin{lstlisting}
procedure print(p : poly; fore, aft, exp : Natural);
\end{lstlisting}
\begin{itemize}
  \item $p$ - The polynomial to print.
  \item fore, aft, and exp - values passed in for floating point formatting.
  \item This is a procedure so no value is returned.  A representation of the polynomial is displayed on the default output.
\end{itemize}

\subsection{Calculus}
Integrals and derivatives of polynomials are fairly easy to generate.  So, functions are provided to take a polynomial and return the integral or the derivative.
\begin{align*}
  \int ax^n dx = a\frac{x^{n+1}}{n+1}+C
\end{align*}
The resulting polynomial for integration has order one greater than the original polynomial.
\begin{lstlisting}
function integrate(p : poly; c : cmplx.Complex) return poly
      with post => (integrate'Result'Last = (p'Last + 1));
\end{lstlisting}
\function{integrate(p : poly; c : cmplx.Complex) return poly}
\begin{itemize}
  \item $p$ - The polynomial to integrate.
  \item $c$ - The constant term.
  \item Returns the integral of $p$.
\end{itemize}

\begin{align*}
  \frac{d}{dx}x^n = n x^{n-1}
\end{align*}
The resulting polynomial for differentiation has order one less than the original polynomial.
\begin{lstlisting}
function derivative(p : poly) return poly
      with post => (((derivative'Result'Last = (p'Last - 1)) and (p'Last > 0)) or
                    ((derivative'Result'Last = 0) and (p'Last = 0)));
\end{lstlisting}
\begin{itemize}
  \item $p$ - The polynomial to differentiate.
  \item Returns the derivative of the original polynomial.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.polynomial\_real}
This is a generic package with a real type parameter, \datatype{F}.

The package defines the datatype \datatype{poly} as \datatype{array (Natural range  <>) of f'Base}, with a constraint that \datatype{poly'First} is equal to 0.  Polynomials are implemented as an array of coefficients where the index in the array represents the exponent of the independent variable.  The index range starts from 0 and extends to the order of the polynomial.  This package contains operations on polynomials with real number coefficients and independent variable.

\subsection{Basic Operations}
The basic binary operations on polynomials, addition (`+'), subtraction (`-'), and multiplication (`*') are implemented and assigned to the operators.  Unary negation (`-') is implemented and assigned to the `-' operator.  Multiplication of a polynomial by a scalar is implemented and assigned to the `*' operator for both scalar first and scalar last.

Division is based on the \function{poludiv()} implementation of synthetic division in \cite{NR-C}.  It divides two polynomials and returns a remainder and quotient.
\begin{align*}
  \frac{u}{v} = q, r
\end{align*}
\begin{lstlisting}
procedure divide(u, v : poly; q : out poly; r : out poly)
      with pre => (q'Last >= (u'Last - v'Last)) and
                  (r'Last >= (v'Last - 1)) and
                  (u'Last >= v'Last);
\end{lstlisting}
\begin{itemize}
  \item $u$ - The numerator for division.
  \item $v$ - The denominator for division.
  \item $q$ - The quotient result of the division.
  \item $r$ - The remainder from the division.
  \item This is a procedure, thus nothing is returned.
\end{itemize}

\subsection{Other Operations}

Evaluate a polynomial at a specific value of the independent variable.
\begin{lstlisting}
function evaluate(p : poly; x : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $p$ - The polynomial to evaluate.
  \item $x$ - The independent variable.
  \item Returns the value of the polynomial evaluated at $x$.
\end{itemize}

Eliminate any leading coefficients with a zero value.  For example $0x^3+x^2+3x+4$ gets trimmed to $x^2+3x+4$.
\begin{lstlisting}
function trim(p : poly) return poly
      with post => (trim'Result'Last <= p'Last);
\end{lstlisting}
\begin{itemize}
  \item $p$ - The polynomial to trim.
  \item Returns the trimmed polynomial of order equal to or less than the original polynomial.
\end{itemize}

Determine the order of a polynomial.  That is the maximum index with a non-zero value.
\begin{lstlisting}
function order(p : poly) return Natural;
\end{lstlisting}
\begin{itemize}
  \item $p$ - The polynomial to determine the order of.
  \item Returns the order of the polynomial.
\end{itemize}

\subsection{Utility}
For development or debugging purposes a simple print polynomial procedure is provided.
\begin{lstlisting}
procedure print(p : poly; fore, aft, exp : Natural);
\end{lstlisting}
\begin{itemize}
  \item $p$ - The polynomial to print.
  \item fore, aft, and exp - values passed in for floating point formatting.
  \item This is a procedure so no value is returned.  A representation of the polynomial is displayed on the default output.
\end{itemize}

\subsection{Calculus}
Integrals and derivatives of polynomials are fairly easy to generate.  So, functions are provided to take a polynomial and return the integral or the derivative.
\begin{align*}
  \int ax^n dx = a\frac{x^{n+1}}{n+1}+C
\end{align*}
The resulting polynomial for integration has order one greater than the original polynomial.
\begin{lstlisting}
function integrate(p : poly; c : f'Base) return poly
      with post => (integrate'Result'Last = (p'Last + 1));
\end{lstlisting}
\begin{itemize}
  \item $p$ - The polynomial to integrate.
  \item $c$ - The constant term.
  \item Returns the integral of $p$.
\end{itemize}

\begin{align*}
  \frac{d}{dx}x^n = n x^{n-1}
\end{align*}
The resulting polynomial for differentiation has order one less than the original polynomial.
\begin{lstlisting}
function derivative(p : poly) return poly
      with post => (((derivative'Result'Last = (p'Last - 1)) and (p'Last > 0)) or
                    ((derivative'Result'Last = 0) and (p'Last = 0)));
\end{lstlisting}
\begin{itemize}
  \item $p$ - The polynomial to differentiate.
  \item Returns the derivative of the original polynomial.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.quaternion}
This is a generic package with a real type parameter, \datatype{F}.

Quaternions are an extension of complex numbers into three dimensions.  A quaternion $q$ is defined as follows:
\begin{align*}
  q=a+b\uvec{i}+c\uvec{j}+d\uvec{k}
\end{align*}
Where
\begin{align*}
  \uvec{i}^2+\uvec{j}^2+\uvec{k}^2=\uvec{i}\uvec{j}\uvec{k}=-1
\end{align*}

This package defines the datatype \datatype{quaternion} as a tagged record with fields $r$, $i$, $j$, and $k$, each of type \datatype{F'Base}.  This means that it is treated as an object and some of the functions can be called in object oriented fashion.

\subsection{Basic Operations}
The basic binary operations on polynomials, addition (`+'), subtraction (`-'), multiplication (`*'), and division (`/') are implemented and assigned to the operators.  Multiplication of a polynomial by a scalar is implemented and assigned to the `*' operator for both scalar first and scalar last.  Note that with quaternions, multiplication is not necessarily commutative.  That is, in general $q_1 q_2 \neq q_2 q_1$.

\subsection{Other Operations}

Compute the magnitude of a quaternion (similar to absolute value) using $|q| = \sqrt{a^2+b^2+c^2+d^2}$.  Note that overflow is possible if any of $a$, $b$, $c$, $d$ are greater than the square root of the maximum value of \datatype{F'Base}.
\begin{lstlisting}
function magnitude(self : in quaternion) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $self$ - The quaternion to have its magnitude returned.
  \item Returns the magnitude of $self$.
\end{itemize}

Scale a quaternion to have a magnitude of 1 (a unit vector).  Since the magnitude is computed to be used as a scale factor, the same comments about overflow apply here.
\begin{lstlisting}
function normalize(self : in quaternion) return quaternion;
\end{lstlisting}
\begin{itemize}
  \item $self$ - The quaternion to be scaled.
  \item Returns a unit quaternion with the same direction as $self$.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.random}
This is not a generic package.

The Ada standard doesn't specify the random number generator to be used.  This package provides two different methods of generating a sequence of pseudo-random numbers.  This package defines an abstract tagged type, \datatype{RNG}, which is used to specify the operations that all random number generators need to provide.  It also defines the type \datatype{double} as \datatype{digits 12}.  This type is used to convert the \datatype{uint32} output of the random number generator into a real number in the range 0.0 to 1.0.

I wrote implementations of these in Java around 2010.  The following routines are based on the Java routines translated into Ada.

\subsection{Linear Congruent Generator}
The linear congruent generator is based on algorithms in \cite{NR-C}.  It provides a datatype \datatype{LCG} which defines an object containing the parameters and state for the generator.  This allows for multiple random number streams with the same or different parameters.

The linear congruent generator is based on the formula:
\begin{align*}
  R_{n+1} = (aR_n + c) \mod modulus
\end{align*}
where $R_0$ is the starting point or seed of the generator.  This generator is fairly fast and has minimal state information.  With a proper choice of parameters, it can produce decent results.  With an improper choice of parameters, the results are not very random.

Initialize the \datatype{LCG} object to some default values.
\begin{lstlisting}
overriding
procedure init(self : in out LCG);
\end{lstlisting}
\begin{itemize}
  \item $self$ - The LCG object to initialize.
\end{itemize}

Initialize the \datatype{LCG} object with specified parameters.  Since the linear-congruent generator is commonly used, parameters can be chosen to emulate the sequence from many other systems.
\begin{lstlisting}
procedure init(self : in out LCG; seed, modulus, a, c : uint32);
\end{lstlisting}
\begin{itemize}
  \item $self$ - The LCG object to initialize.
  \item $seed$ - The initial value for the generator.
  \item $modulus$ - The modulus for the generator.
  \item $a$ - The $a$ coefficient in the generator formula.
  \item $c$ - The $c$ coefficient in the generator formula.
\end{itemize}

The initial, ($seed$) value can be set in a generator without changing the other values.
\begin{lstlisting}
procedure setSeed(self : in out LCG; seed : uint32);
\end{lstlisting}
\begin{itemize}
  \item $self$ - The LCG object to adjust.
  \item $seed$ - The new seed value.
\end{itemize}

Return the next random number in raw format as a \datatype{uint32}.
\begin{lstlisting}
overriding
function getNext(self : in out LCG) return uint32;
\end{lstlisting}
\begin{itemize}
  \item $self$ - The LCG object to get the next random number from.
  \item Returns the next \datatype{uint32} in the sequence.
\end{itemize}

Return the next random number as a floating point in the range 0.0 to 1.0.  This can then be cast to the desired real number type.
\begin{lstlisting}
overriding
function getNextF(self : in out LCG) return double;
\end{lstlisting}
\begin{itemize}
  \item $self$ - The LCG object to get the next random number from.
  \item Returns the next real number in the sequence.
\end{itemize}

\subsection{Mersenne Twister Generator}
The mersenne twister generator is based on algorithms in \cite{MT19937}.  It provides a datatype \datatype{MT} which defines an object containing the parameters and state for the generator.  This allows for multiple random number streams with the same or different parameters.  While this generator is fairly fast, it requires about 624 \datatype{uint32} values of state information, thus considerably more memory than \datatype{LCG}.

Initialize the \datatype{MT} object to some default values.
\begin{lstlisting}
overriding
procedure init(self : in out MT);
\end{lstlisting}
\begin{itemize}
  \item $self$ - The MT object to initialize.
\end{itemize}

Initialize the \datatype{MT} object with specified seed.
\begin{lstlisting}
procedure init(self : in out MT; seed : uint32);
\end{lstlisting}
\begin{itemize}
  \item $self$ - The LCG object to initialize.
  \item $seed$ - The initial value for the generator.
\end{itemize}

Return the next random number in raw format as a \datatype{uint32}.
\begin{lstlisting}
overriding
function getNext(self : in out MT) return uint32;
\end{lstlisting}
\begin{itemize}
  \item $self$ - The MT object to get the next random number from.
  \item Returns the next \datatype{uint32} in the sequence.
\end{itemize}

Return the next random number as a floating point in the range 0.0 to 1.0.  This can then be cast to the desired real number type.
\begin{lstlisting}
overriding
function getNextF(self : in out MT) return double;
\end{lstlisting}
\begin{itemize}
  \item $self$ - The MT object to get the next random number from.
  \item Returns the next real number in the sequence.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.regression}
This is a generic package with a real type parameter, \datatype{F}.  It defines the following datatypes:
\begin{itemize}
  \item \datatype{point} which is a record of two fields: $x$ and $y$, both of which are \datatype{F'Base}.
  \item \datatype{data\_array} as an array of \datatype{point}.
  \item \datatype{simple\_linreg\_result} is a record containing the results of simple linear regression.  The fields are:
  \begin{itemize}
    \item $a$ - The Y intercept
    \item $b$ - The slope
    \item $SSe$ - The sum of square errors
    \item $var$ - The sum of square errors normalized by the degrees of freedom ($n-2$).
    \item $Bvar$ - The variance of the slope.
    \item $cor$ - The correlation coefficient (R) (note that correlation does not imply causation).
  \end{itemize}
\end{itemize}

\subsection{Simple Linear Regression}
Given a set of ($x$, $y$) points where $x$ is assumed to have no error, and the errors on $y$ are assumed to have a mean of zero, normal distribution, and constant variance, find the line, $y=ax+b+\epsilon$, where $\epsilon$ is the error, that best fits the data.
\begin{lstlisting}
function simple_linear(d : data_array) return simple_linreg_result;
\end{lstlisting}
\begin{itemize}
  \item $d$ - An array of the data points to analyze.
  \item Returns a record of type \datatype{simple\_linreg\_result} containing the parameters for the line as well as estimates of how good the fit is.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.roots\_complex}
This is a generic package with a complex package parameter, \datatype{cmplx}.  This has datatypes \datatype{cmplx.Complex} and \datatype{cmplx.Real}.  It contains methods for finding roots of equations with complex variables.

It defines the following datatypes:
\begin{itemize}
   \item \datatype{test\_func} as \datatype{access function (x : cmplx.complex) return cmplx.complex}
   \item \datatype{errors} as an enumeration of \datatype{(none, bad\_args, no\_solution)}
\end{itemize}

Solve for (possibly) complex roots using Mueller's method.  Mueller's method starts with three initial approximations to the root and solves the parabola through these three points to produce the next approximation.
\begin{lstlisting}
function mueller(test : test_func; x0, x2 : in out cmplx.complex;
         limit : in out Positive; err : out errors) return cmplx.complex;
\end{lstlisting}
\begin{itemize}
  \item $test$ - The function to find a root of.
  \item $x0$ and $x2$ - Starting points for the root finding
  \item $limit$ - The number of iterations.
  \item $err$ - An error code.
  \item Returns an estimate of a root of the function.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.roots\_real}
This is a generic package with a real type parameter, \datatype{F}.  It contains methods for finding roots of equations with complex variables.

It defines the following datatypes:
\begin{itemize}
   \item \datatype{test\_func} as \datatype{access function (x : f'Base) return f'Base}
   \item \datatype{errors} as an enumeration of \datatype{(none, bad\_args, no\_solution)}
\end{itemize}

\subsection{Linear Methods}
If there is an odd number of roots between the lower and upper limits, the bisection algorithm will always converge.  Each iteration simply halves the interval between the limits, keeping a root between them.  The result is the midpoint of the final interval after the specified number of iterations.

The lower and upper values are updated during the iterations to provide an interval containing the root.
\begin{lstlisting}
function bisection(test : test_func; lower, upper : in out f'Base;
         limit : Positive; err : out errors) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $test$ - The function to find a root of.
  \item $lower$ - The lower bound of the interval for the root.
  \item $upper$ - The upper bound of the interval for the root.
  \item $limit$ - The number of iterations.
  \item $err$ - An error code.
  \item Returns an estimate of a root of the function.
\end{itemize}

If there is an odd number of roots between the lower and upper limits, the secant method will always converge.  Each stage of the iteration identifies a point where a line between the lower and upper values crosses the axis.  This point is used instead of the midpoint in the bisection algorithm.

Depending on the function, this can converge to a root much faster than the bisection algorithm.  On the other had, it can also converge much slower.

The lower and upper values are updated during the iterations to provide an interval containing the root.  If the root is exact, the lower and upper values are equal to the returned value.

This method will fail if during the process, the function values at the upper and lower bounds are ever equal.  This will cause a divide by zero error.
\begin{lstlisting}
function seacant(test : test_func; lower, upper : in out f'Base;
         limit : Positive; err : out errors) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $test$ - The function to find a root of.
  \item $lower$ - The lower bound of the interval for the root.
  \item $upper$ - The upper bound of the interval for the root.
  \item $limit$ - The number of iterations.
  \item $err$ - An error code.
  \item Returns an estimate of a root of the function.
\end{itemize}

\subsection{Mueller's Method}
Mueller's method uses three points to model a quadratic curve and uses that to find a candidate root.    Unlike the bisection method, Mueller's method does not require a root to be located within the three points.  This can potentially be used to find complex roots, however this implementation does not.

This method will fail if the function value at the three points is equal.

In this implementation, the user provides two points and the third is generated as the average of these two points.  This keeps the call the same as the bisection and secant functions.

Note that for this algorithm, the x0 and x2 values are not necessarily meaningful as upper and lower bounds for the root, except that they are both set equal to the return value if the root is exact.

Note that the success may be sensitive to the choice of x0 and x2.  If you know that a root exists and get a no\_solution error, try different values.
\begin{lstlisting}
function mueller(test : test_func; x0, x2 : in out f'Base;
         limit : in out Positive; err : out errors) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $test$ - The function to find a root of.
  \item $x0$ and $x2$ - Starting points for the root finding
  \item $limit$ - The number of iterations.
  \item $err$ - An error code.
  \item Returns an estimate of a root of the function.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.statistics}
This is a generic package with a real type parameter, \datatype{F}.  It contains a number of statistics related routines.  It defines the datatype \datatype{data\_array} as \datatype{array (Integer range <>) of F'Base}.

\subsection{Data Statistics}
These routines compute statistics on the values in a \datatype{data\_array}.

Compute the mean of a set of values.  For $n$ values, computes:
\begin{align*}
  m = \frac{1}{n}\sum_{i=1}^n d_i
\end{align*}
\begin{lstlisting}
function mean(d : data_array) return F'Base;
\end{lstlisting}
\begin{itemize}
  \item $d$ - The array containing the data.
  \item Returns the mean value of the data.
\end{itemize}

Compute the limits of a set of data.
\begin{lstlisting}
procedure limits(d : data_array; min : out F'Base; max : out F'Base);
\end{lstlisting}
\begin{itemize}
  \item $d$ - The array containing the data.
  \item $min$ - Output as the minimum value in the array.
  \item $max$ - Output as the maximum value in the array.
  \item This is a procedure and does not return a value.
\end{itemize}

Compute the variance of a set of data.  Since computing the variance also requires computing the mean, this procedure returns both values.
\begin{lstlisting}
procedure variance(d : data_array; var : out F'Base; mean : out F'Base);
\end{lstlisting}
\begin{itemize}
  \item $d$ - The array containing the data.
  \item $var$ - Output as the variance of the data in the array.
  \item $mean$ - Output as the mean of the data in the array.
  \item This is a procedure and does not return a value.
\end{itemize}

\subsection{Probability Distributions}
Note on naming conventions for probability distributions.  For continuous distribution functions, there are generally two functions.  The one with the ``\_pdf'' suffix is the probability density function.  The one with the ``\_cdf'' suffix is the cumulative distribution function.  For discrete functions, the ``\_pmf'' suffix is for the probability mass function.

\subsubsection{Normal Distribution}
Compute the standard normal distribution where the PDF is given by $x = e^{-p^2}$.
\begin{lstlisting}
function normal_pdf(p : F'Base) return F'Base;
\end{lstlisting}
\begin{itemize}
  \item $p$ - The value.
  \item Returns the probability density at point $p$.
\end{itemize}

Compute the normal distribution with a specified mean and standard deviation ($\sigma$).
\begin{lstlisting}
function normal_pdf(p, mean, sigma : F'Base) return F'Base;
\end{lstlisting}
\begin{itemize}
  \item $p$ - The value.
  \item $mean$ - The mean of the distribution.
  \item $sigma$ - The standard deviation of the distribution.
  \item Returns the probability density at point $p$.
\end{itemize}

Compute the normal cumulative distribution for the standard normal function.  This is computed by integrating the standard normal function from $a$ to $b$.
\begin{align*}
  p = \int^b_a e^{-x^2} dx
\end{align*}
\begin{lstlisting}
function normal_cdf(a, b : F'Base; steps : Positive) return F'Base;
\end{lstlisting}
\begin{itemize}
  \item $a$ - Starting point for integration.
  \item $b$ - Ending point for integration.
  \item $steps$ - Number of steps for Simpson's rule integration.
  \item Returns the cumulative probability between $a$ and $b$.
\end{itemize}

\subsubsection{$\chi^2$ Distribution}
Compute the $\chi^2$ distribution where the PDF is given by:
\begin{align*}
  p = \frac{1}{2^{\frac{k}{2}}\Gamma(\frac{k}{2})}x^{\frac{k}{2}-1}e^{-\frac{x}{2}}
\end{align*}
\begin{lstlisting}
function chi2_pdf(x : f'Base; k : Positive) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $x$ - The value.
  \item $k$ - The number of degrees of freedom.  Must be greater than zero.
  \item Returns the probability density at point $x$.
\end{itemize}

Compute the cumulative $\chi^2$ between $a$ and $b$.
\begin{lstlisting}
function chi2_cdf(a, b : F'Base; k, steps : Positive) return F'Base;
\end{lstlisting}
\begin{itemize}
  \item $a$ - Starting point for integration.
  \item $b$ - Ending point for integration.
  \item $steps$ - Recursion depth for adaptive Simpson's rule integration.
  \item Returns the cumulative probability between $a$ and $b$.
\end{itemize}

\subsubsection{Student's T Distribution}
Compute the student's t distribution where the PDF is given by:
\begin{align*}
  p = \frac{\Gamma(\frac{\nu+1}{2})}{\sqrt{\pi\nu}\Gamma(\frac{\nu}{2})}(1+\frac{t^2}{\nu})^{-\frac{\nu+1}{2}}
\end{align*}
\begin{lstlisting}
function studentT_pdf(t : f'Base; nu : Positive) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $t$ - The value.
  \item $nu$ - Shape parameter ($\nu$).
  \item Returns the probability density at point $t$.
\end{itemize}

Compute the cumulative student t between $a$ and $b$.
\begin{lstlisting}
function studentT_cdf(a, b : F'Base; nu, steps : Positive) return F'Base;
\end{lstlisting}
\begin{itemize}
  \item $a$ - Starting point for integration.
  \item $b$ - Ending point for integration.
  \item $steps$ - Recursion depth for adaptive Simpson's rule integration.
  \item Returns the cumulative probability between $a$ and $b$.
\end{itemize}

\subsubsection{Exponential Distribution}
Compute the exponential distribution where the PDF is given by $\lambda e^{-\lambda x}$.
\begin{lstlisting}
function exp_pdf(x, lambda : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $x$ - The value.
  \item $lambda$ - The shape parameter ($\lambda$)
  \item Returns the probability at point $x$.
\end{itemize}

Compute the cumulative exponential between $0$ and $x$.  This is given by $1-e^{-\lambda x}$
\begin{lstlisting}
function exp_cdf(x, lambda : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $x$ - The value.
  \item $lambda$ - The shape parameter ($\lambda$)
  \item Returns the cumulative probability from $0$ to $x$.
\end{itemize}

\subsubsection{Poisson Distribution}
Since the Poisson Distribution is a discrete distribution rather than a cumulative distribution, we compute a probability mass function.  This is given by:
\begin{align*}
  p(k) = \frac{\lambda^k e^{-\lambda}}{k!}
\end{align*}
\begin{lstlisting}
function poisson_pmf(k : Natural; lambda : Positive) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $k$ - The value.
  \item $lambda$ - The shape parameter ($\lambda$)
  \item Returns the probability of $k$.
\end{itemize}

\subsection{Statistical Tests}
\subsubsection{Student's T Tests}
Use the one sample t test to compare the mean of a sample to a specified mean.  Given the sample mean, $\bar{x}$, the sample standard deviation, $s$, and the sample size, $n$, compute the student's t statistic for the difference between $\bar{x}$ and the specified mean, $\mu_0$.
\begin{lstlisting}
function studentT_one(x_bar, mu0, s, n : f'Base) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $x_bar$ - The sample mean ($\bar{x}$).
  \item $mu0$ - The specified mean ($\mu_0$).
  \item $s$ - The sample standard deviation ($s$).
  \item $n$ - The number of samples ($n$).
  \item Returns the t statistic for the difference between the $\bar{x}$ and $\mu_0$.
\end{itemize}

%--------------------------------------------------------------------------------------------------
\section{BBS.Numerical.vector}
This is a generic package with a real type parameter, \datatype{F}.  It contains some vector related routines.  It defines the datatype \datatype{vect} as \datatype{array (integer range <>) of f'Base}

\subsection{Basic Operations}
Addition (`+') and subtraction (`-') of vectors is defined and assigned to the operators.  These operations require both vectors to have the same index ranges and return a vector with the same index range.

Multiplication (`*') of vectors is defined and assigned to the operator.  It requires both vectors to have the same index and returns the scaler dot product of the vectors.

Multiplication (`*') of a vector by a scaler is defined and assigned to the operator for both scaler first and scaler last.  It returns a vector with the same index range as the source vector.

\subsection{Other Operations}

Compute the magnitude of a vector by taking the square root of the sum of the squares of the elements.  Note that overflow is possible if any of the elements are greater than the square root of the maximum value of \datatype{F'Base}.
\begin{lstlisting}
function magnitude(self : in vect) return f'Base;
\end{lstlisting}
\begin{itemize}
  \item $self$ - The vector to take the magnitude of.
  \item Returns the magnitude of the vector.
\end{itemize}

Scale the elements in a vector so that the vector has a magnitude of one.  The same overflow warning for the \function{magnitude} function also apply here.
\begin{lstlisting}
function normalize(self : in vect) return vect;
\end{lstlisting}
\begin{itemize}
  \item $self$ - The vector to normalize.
  \item Returns the normalized vector.
\end{itemize}

%========================================================
\clearpage
\addcontentsline{toc}{chapter}{Bibliography}
\nocite{NA3rd}
\bibliographystyle{plain}
\bibliography{Numerical.bib}

\end{document}

