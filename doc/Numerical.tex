\documentclass[10pt, openany]{book}

\usepackage{fancyhdr}
\usepackage{imakeidx}

\usepackage{amsmath}
\usepackage{amsfonts}

\usepackage{geometry}
\geometry{letterpaper}

\usepackage{fancyvrb}
\usepackage{fancybox}

\usepackage{url}
\usepackage{multicol}
%
% Rules to allow import of graphics files in EPS format
%
\usepackage{graphicx}
\DeclareGraphicsExtensions{.eps}
\DeclareGraphicsRule{.eps}{eps}{.eps}{}
%
%  Include the listings package
%
\usepackage{listings}
%
%  For bibliography
%
%\usepackage{biblatex}
%\addbibresource{Numerical.bib}
%
% Macro definitions
%
\newcommand{\operation}[1]{\textbf{\texttt{#1}}}
\newcommand{\package}[1]{\texttt{#1}}
\newcommand{\function}[1]{\texttt{#1}}
\newcommand{\constant}[1]{\emph{\texttt{#1}}}
\newcommand{\keyword}[1]{\texttt{#1}}
\newcommand{\datatype}[1]{\texttt{#1}}
\newcommand{\uvec}[1]{\textnormal{\bfseries{#1}}}
%
% Front Matter
%
\title{Basic Numerical Analysis Routines}
\author{Brent Seidel \\ Phoenix, AZ}
\date{ \today }
%========================================================
%%% BEGIN DOCUMENT
\begin{document}
%
% Produce the front matter
%
\frontmatter
\maketitle
\begin{center}
This document is \copyright 2024 Brent Seidel.  All rights reserved.

\paragraph{}Note that this is a draft version and not the final version for publication.
\end{center}
\tableofcontents

\mainmatter
%----------------------------------------------------------
\chapter{Introduction}

Back in the 1980s when I was an undergraduate, I took a numerical analysis course and quite enjoyed it.  Then my first job out of college was working on a numerical analysis library for a small startup that went the way of most startups.  I was recently inspired to dig out my old textbook and try implementing some of the routines.  This collection includes some of those, plus others.

Note that some packages are for complex numbers and some are for real numbers.  At some point, they may be combined.  Most packages are generic.  The packages are:

\section{BBS.Numerical.complex}
This is an object oriented collection of complex number routines.  After writing this, I discovered \package{Ada.Numerics.Generic\_Complex\_Types}.  So this package is deprecated in favor of the Ada package.

\section{BBS.Numerical.derivative}
This is a generic package with a real type parameter.  It contains functions to compute the derivative of real valued functions with a single argument.

\section{BBS.Numerical.functions}
This is a generic package with a real type parameter.  It contains some functions that are used by other packages.

\section{BBS.Numerical.integration\_real}
This is a generic package with a real type parameter.  It contains functions to compute integrals of real valued functions with a single argument.

\section{BBS.Numerical.interpolation}
This is a generic package with a real type parameter.  It contains functions to interpolate a value between a set of data points.  The functions can also extrapolate (if using a value of $x$ outside of the range of the data points, however this is likely to be inaccurate.

\section{BBS.Numerical.ode}
This is a generic package with a real type parameter.  It contains functions to solve ordinary differential equations.

\section{BBS.Numerical.polynomial\_complex}
This is a generic package with a complex type parameter (from \package{Ada.Numerics.Generic\_Complex\_Types}.  It contains functions for polynomials.

\section{BBS.Numerical.polynomial\_real}
This is a generic package with a real type parameter.  It contains functions for polynomials.

\section{BBS.Numerical.quaternion}
This is a generic package with a real type parameter.  It contains functions for quaternions.

\section{BBS.Numerical.random}
This is not a generic package.  It contains functions for generating pseudo-random numbers.

\section{BBS.Numerical.regression}
This is a generic package with a real type parameter.  It contains functions for performing regression analysis of data.

\section{BBS.Numerical.roots\_complex}
This is a generic package with a complex type parameter (from \package{Ada.Numerics.Generic\_Complex\_Types}.  It contains functions for finding zeros of functions.

\section{BBS.Numerical.roots\_real}
This is a generic package with a real type parameter.  It contains functions for finding zeros of functions.

\section{BBS.Numerical.statistics}
This is a generic package with a real type parameter.  It contains statistics related functions.

\section{BBS.Numerical.vector}
This is a generic package with a real type parameter.  It contains functions for vectors.


%----------------------------------------------------------
\chapter{How to Obtain}

This collections is currently available on GitHub at \url{https://github.com/BrentSeidel/Numerical}.

\section{Dependencies}
\subsection{Ada Libraries}
The following Ada libraries are used:
\begin{itemize}
  \item \package{Ada.Numerics}
  \item \package{Ada.Numerics.Generic\_Complex\_Types}
  \item \package{Ada.Numerics.Generic\_Complex\_Elementary\_Functions}
  \item \package{Ada.Numerics.Generic\_Elementary\_Functions}
  \item \package{Ada.Text\_IO} (used for debugging purposes)
\end{itemize}
\subsection{Other Libraries}
This library depends on the root package \package{BBS} available at \url{https://github.com/BrentSeidel/BBS-Ada}.
Internal packages used within this library are:
\begin{itemize}
  \item \package{BBS.Numerical.functions}
  \item \package{BBS.Numerical.Integration\_real}
\end{itemize}

%----------------------------------------------------------
\chapter{Usage Instructions}
This is a library of routines intended to be used by some program.  To use these in your program, edit your *\keyword{.gpr} file to include a line to \keyword{with} the path to \keyword{BBS\_Numerical.gpr}.  Then in your Ada code \keyword{with} in the package(s) you need and use the routines.

%----------------------------------------------------------
\chapter{API Description}
\section{BBS.Numerical.complex}
This package is deprecated in favor of the Ada package \package{Ada.Numerics.Generic\_Complex\_Types}.

\section{BBS.Numerical.derivative}
This is a generic package with a real type parameter, \datatype{F}.

It defines a function type \datatype{test\_func} as \datatype{access function (x : f'Base) return f'Base}.

WARNING:
The calculations here may involve adding small numbers to large numbers and taking the difference of two nearly equal numbers.
The world of computers is not the world of mathematics where numbers have infinite precision.  If you aren't careful, you can get into a situation where $(x + h) = x$, or $f(x) = f(x \pm h)$. For example assume that the float type has 6 digits.  Then, if $x$ is $1,000,000$ and $h$ is $1$, adding $x$ and $h$ is a wasted operation.

The functions are:
\subsection{Two Point Formulas}
Two point formula.  Use $h>0$ for forward-difference and $h<0$ for backward-difference.  Derivative calculated at point $x$.  While this is the basis for defining the derivative in calculus, it generally shouldn't be used.

\function{pt2(f1 : test\_func; x, h : f'Base) return f'Base}
\begin{itemize}
  \item \function{f1} - the function that you with to find the derivative of
  \item \function{x} - the point at which to calculate the derivative
  \item \function{h} - the step size
\end{itemize}

\subsection{Three Point Formulas}
Compute the derivative at $x$ using values at $x$, $x+h$, and $x+2h$.

\function{pt3a(f1 : test\_func; x, h : f'Base) return f'Base}
\begin{itemize}
  \item \function{f1} - the function that you with to find the derivative of
  \item \function{x} - the point at which to calculate the derivative
  \item \function{h} - the step size
\end{itemize}

Compute the derivative at $x$ using values at $x-h$ and $x+h$.

\function{pt3b(f1 : test\_func; x, h : f'Base) return f'Base}
\begin{itemize}
  \item \function{f1} - the function that you with to find the derivative of
  \item \function{x} - the point at which to calculate the derivative
  \item \function{h} - the step size
\end{itemize}

\subsection{Five Point Formulas}

Compute the derivative at $x$ using values at $x-2h$, $x-h$, $x+h$, and $x+2h$.

\function{pt5a(f1 : test\_func; x, h : f'Base) return f'Base}
\begin{itemize}
  \item \function{f1} - the function that you with to find the derivative of
  \item \function{x} - the point at which to calculate the derivative
  \item \function{h} - the step size
\end{itemize}

Compute the derivative at $x$ using values at $x$, $x+h$, $x+2h$, $x+3h$, and $x+4h$.

\function{pt5b(f1 : test\_func; x, h : f'Base) return f'Base}
\begin{itemize}
  \item \function{f1} - the function that you with to find the derivative of
  \item \function{x} - the point at which to calculate the derivative
  \item \function{h} - the step size
\end{itemize}

\section{BBS.Numerical.functions}
This is a generic package with a real type parameter, \datatype{F}.  Its primary purpose is to contain functions that are used by other packages in this library.  They may also be useful to the end user.

\subsection{Gamma Function Related}
Some of the probability functions require computing $\Gamma(\frac{n}{2})$.  Since $\Gamma(\frac{1}{2})=\sqrt{pi}$, $\Gamma(1) = 1$, and $\Gamma(a+1) = a*\Gamma(a)$, computing $\Gamma(\frac{n}{2})$, where $n$ is a positive integer is simpler than computing the full $\Gamma$ function.

Computes $\Gamma$ of $2n$.  Note that this will overflow for \datatype{Float} for $n>70$.

\function{gamma2n(n : Positive) return f'Base}
\begin{itemize}
  \item $n$ - A positive integer representing twice the value for computing $\Gamma$.
  \item Returns the actual value.
\end{itemize}

To compute $\Gamma$ of $2n$ where $n>70$, logarithms can be used.  This returns the $log_e(\Gamma(n))$.

\function{lngamma2n(n : Positive) return f'Base}
\begin{itemize}
  \item $n$ - A positive integer representing twice the value for computing $\Gamma$.
  \item Returns the natural log of the value.
\end{itemize}

\subsection{Factorial Related}
The factorial functions are similar to the $\Gamma$ functions.  Since the parameter is not divided by two in this case, overflow will occur for $n>35$.  Thus, as for $\Gamma$, there are two versions.  The first returns the actual value, the second returns the natural log of the value.

\function{factorial(n : Natural) return f'Base}
\begin{itemize}
  \item $n$ - A natural integer representing.
  \item Returns the actual factorial value.
\end{itemize}
\function{lnfact(n : Natural) return f'Base}
\begin{itemize}
  \item $n$ - A natural integer representing.
  \item Returns the natural log of the factorial value.
\end{itemize}

\subsection{Combinatorial Related}
The one function computes the binomial coefficients (aka N choose K).  By definition, this computes:
\begin{displaymath}
  \binom{n}{k} = \frac{n!}{k!(b-k)!}
\end{displaymath}
With some algebra, this becomes:
\begin{displaymath}
  \binom{n}{k} = \prod^k_{i=1}\frac{n+1-i}{i}
\end{displaymath}
 which is easier to compute.  The function is:

\function{nChoosek(n, k : Natural) return f'Base}
\begin{itemize}
  \item $n$ - The number of items.
  \item $k$ - The number of items to choose.
  \item There is a restriction that $n\geq{}k$
\end{itemize}

\section{BBS.Numerical.integration\_real}
This is a generic package with a real type parameter, \datatype{F}.

It defines a function type \datatype{test\_func} as \datatype{access function (x : f'Base) return f'Base}.

This package contains routines to perform numerical integration of a function with one parameter.  Thus it computes an approximation to:
\begin{displaymath}
  y = \int_a^b f(x) dx
\end{displaymath}

\subsection{Trapezoid Rule}
This estimates the value of the integral using the composite trapezoid rule.

\function{trapezoid(test : test\_func; lower, upper : f'Base; steps : Positive) return f'Base}
\begin{itemize}
  \item $test$ - The function to integrate.  It must match the datatype for \datatype{test\_func}.
  \item $lower$ - The lower bounds of the integration.
  \item $upper$ - The upper bounds of the integration.
  \item $steps$ - The number of steps to use.
\end{itemize}

\subsection{Simpson's Rule}
This estimates the value of the integral using the composite Simpson's rule.

\function{simpson(test : test\_func; lower, upper : f'Base; steps : Positive) return f'Base}
\begin{itemize}
  \item $test$ - The function to integrate.  It must match the datatype for \datatype{test\_func}.
  \item $lower$ - The lower bounds of the integration.
  \item $upper$ - The upper bounds of the integration.
  \item $steps$ - The number of steps to use.
\end{itemize}

\subsection{Adaptive Simpson's}
This estimates the value of the integral using an adaptive version of Simpson's rule.  The interval is divided into two and each side is evaluated using the composite Simpson's with 1 and 2 steps.  The difference between the two evaluations is used as an error estimate.  If the error is two big, the interval is divided again and the function recurses until either the recursion limit is reached or the error is within limits.

\function{adapt\_simpson(test : test\_func; lower, upper : f'Base; tol : in out f'Base;  levels : Natural) return f'Base}
\begin{itemize}
  \item $test$ - The function to integrate.  It must match the datatype for \datatype{test\_func}.
  \item $lower$ - The lower bounds of the integration.
  \item $upper$ - The upper bounds of the integration.
  \item $tol$ - The desired error limit.  This also returns the estimated error.
  \item $levels$ - The allowed recursion depth.
\end{itemize}

\section{BBS.Numerical.interpolation}
This is a generic package with a real type parameter, \datatype{F}.  It uses Lagrange polynomials to interpolate a value given a set of points.  The following data types are defined:
\begin{itemize}
  \item \datatype{point} - A record with $x$ and $y$ values of type \datatype{F}.
  \item \datatype{points} - A currently unused array of \datatype{point}.
\end{itemize}
Interpolation is most accurate within the range of the provided data points.  Outside of that range, it becomes extrapolation and may become increasingly inaccurate.  While higher order methods tend to be more accurate, there is also a potential for oscillations.  It is important to understand your data - if the data is linear or nearly so, using a 5th order method is probably a mistake.

\function{lag2(p0, p1 : point; x : f'Base) return f'Base}
\begin{itemize}
  \item Interpolation with two points is linear interpolation.  The data is approximated as $y = ax+b$.
  \item $p0$ - The first known point.
  \item $p1$ - The second known point.
  \item $x$ - The location to interpolate.
\end{itemize}

\function{lag3(p0, p1, p2 : point; x : f'Base) return f'Base}
\begin{itemize}
  \item Interpolation with three points is quadratic interpolation.  The data is approximated as $y = ax^2+bx+c$.
  \item $p0$ - The first known point.
  \item $p1$ - The second known point.
  \item $p2$ - The third known point.
  \item $x$ - The location to interpolate.
\end{itemize}

\function{lag4(p0, p1, p2, p3 : point; x : f'Base) return f'Base}
\begin{itemize}
  \item Interpolation with four points is cubic interpolation.  The data is approximated as $y = ax^3+bx^2+cx+d$.
  \item $p0$ - The first known point.
  \item $p1$ - The second known point.
  \item $p2$ - The third known point.
  \item $p3$ - The fourth known point.
  \item $x$ - The location to interpolate.
\end{itemize}

\function{lag5(p0, p1, p2, p3, p4 : point; x : f'Base) return f'Base}
\begin{itemize}
  \item Interpolation with five points is quartic interpolation.  The data is approximated as $y = ax^4+bx^3+cx^2+dx+e$.
  \item $p0$ - The first known point.
  \item $p1$ - The second known point.
  \item $p2$ - The third known point.
  \item $p3$ - The fourth known point.
  \item $p4$ - The fifth known point.
  \item $x$ - The location to interpolate.
\end{itemize}

\section{BBS.Numerical.ode}
This is a generic package with a real type parameter, \datatype{F}.  It contains methods for numerically solving differential equations.

It defines the following datatypes:
\begin{itemize}
   \item \datatype{test\_func} as \datatype{access function (t, y : f'Base) return f'Base}
   \item \datatype{params} as \datatype{array (integer range <>) of f'Base}
   \item \datatype{sys\_func} as \datatype{access function (t : f'Base; y : params) return f'Base}
   \item \datatype{functs} as \datatype{array (integer range <>) of sys\_func}
\end{itemize}

The goal is to solve an equations:
\begin{displaymath}
  \frac{dy}{dt} = f(t, y)
\end{displaymath}
 for $a\leq t\leq b$, and $y(a) = \alpha$
 
\subsection{Historical}
Euler's method is mostly of historic interest.  It may be used if the function is expensive to evaluate and accuracy isn't very important.  It most case however, there are better methods.

\function{euler(tf : test\_func; start, initial, step : f'Base) return f'Base}
\begin{itemize}
  \item $tf$ - The differential equation to solve.
  \item $start$ - The starting independent value for the step ($a$).
  \item $initial$ - The initial value of the differential equation ($\alpha$).
  \item $step$ - The step size.
\end{itemize}

\subsection{Runge-Kutta Methods}
The 4th order Runge-Kutta method is the workhorse differential equation solver.

\function{rk4(tf : test\_func; start, initial, step : f'Base) return f'Base}
\begin{itemize}
  \item $tf$ - The differential equation to solve.
  \item $start$ - The starting independent value for the step ($a$).
  \item $initial$ - The initial value of the differential equation ($\alpha$).
  \item $step$ - The step size.
\end{itemize}

By combining a specific 4th order with specific 5th order Runge-Kutta method, one can produce an error estimate.  This is the Runge-Kutta-Fehlber method.  The error estimate can be used to adjust the step size, if needed to improve accuracy.

\function{rkf(tf : test\_func; start, initial, step : f'Base; tol : out f'Base) return f'Base}
\begin{itemize}
  \item $tf$ - The differential equation to solve.
  \item $start$ - The starting independent value for the step ($a$).
  \item $initial$ - The initial value of the differential equation ($\alpha$).
  \item $step$ - The step size.
  \item $tol$ - The error estimate as an output.
\end{itemize}

\subsection{Multistep Methods}
The multistep methods depends on the values at multiple previous positions rather than just an initial value.  Thus, generally another method (typically a Runge-Kutta) method is used to generate these values.

Fourth order Adams-Bashforth method.  This is a four step explicit method.

\function{ab4(tf : test\_func; start, step : f'Base; i0, i1, i2, i3 : f'Base) return f'Base}
\begin{itemize}
  \item $tf$ - The differential equation to solve.
  \item $start$ - The starting independent value for the step ($a$).
  \item $step$ - The step size.
  \item $i0$ - The initial value of the differential equation ($\alpha$).
  \item $i1$ - The initial value of the differential equation ($\alpha_1$).
  \item $i2$ - The initial value of the differential equation ($\alpha_2$).
  \item $i3$ - The initial value of the differential equation ($\alpha_3$).
\end{itemize}

Fourth order Adams-Moulton method.  This is a three step implicit method.

\function{am4(tf : test\_func; start, step : f'Base; i0, i1, i2, i3 : f'Base) return f'Base}
\begin{itemize}
  \item $tf$ - The differential equation to solve.
  \item $start$ - The starting independent value for the step ($a$).
  \item $step$ - The step size.
  \item $i0$ - The initial value of the differential equation ($\alpha$).
  \item $i1$ - The initial value of the differential equation ($\alpha_1$).
  \item $i2$ - The initial value of the differential equation ($\alpha_2$).
  \item $i3$ - The initial value of the differential equation ($\alpha_3$).
\end{itemize}

Fourth order Adams-Bashforth/Adams-Moutlton method.  This uses the Adams-Bashforth method to predict the final value and then uses the Adams-Moulton method to refine that value as a corrector method.

\function{abam4(tf : test\_func; start, step : f'Base; i0, i1, i2, i3 : f'Base) return f'Base}
\begin{itemize}
  \item $tf$ - The differential equation to solve.
  \item $start$ - The starting independent value for the step ($a$).
  \item $step$ - The step size.
  \item $i0$ - The initial value of the differential equation ($\alpha$).
  \item $i1$ - The initial value of the differential equation ($\alpha_1$).
  \item $i2$ - The initial value of the differential equation ($\alpha_2$).
  \item $i3$ - The initial value of the differential equation ($\alpha_3$).
\end{itemize}

\subsection{Systems of Differential Equations}
The previous methods solve a single first order differential equation.  If you have a higher order equation or a system of coupled equations, then you need a method that works on systems of differential equations.  An nth order system of first order equations has the form:
\begin{align*}
  \frac{dy_1}{dt} &= f_1(t, y_1, ..., y_n) \\
  \frac{dy_2}{dt} &= f_2(t, y_1, ..., y_n) \\
  &\vdots\\
  \frac{dy_n}{dt} &= f_n(t, y_1, ..., y_n)
\end{align*}
with $a\leq t\leq b$, and initial conditions:
\begin{align*}
  y_1(a) &= \alpha_1 \\
  y_2(a) &= \alpha_2 \\
  &\vdots \\
  y_n(a) &= \alpha_n
\end{align*}

To solve higher order differential equations, they need to be transformed into a system of first order equations.

\function{function rk4s(tf : functs; start : f'Base; initial : params; step : f'Base) return params}
\begin{itemize}
  \item $tf$ - An array containing the system of differential equations to solve ($f_1 ... f_n$).
  \item $start$ - The starting independent value for the step ($a$).
  \item $initial$ - An array containing the initial values for the system of differential equation ($\alpha_1 ... \alpha_n$).
  \item $step$ - The step size.
  \item There is a restriction that the array bounds for $tf$ and $initial$ must be the same.
  \item The returned array has the same bounds as $tf$ and $initial$.
\end{itemize}

\section{BBS.Numerical.polynomial\_complex}
This is a generic package with a complex package parameter, \datatype{cmplx}.  This parameter has datatypes \datatype{cmplx.Complex} and \datatype{cmplx.Real}.

The package defines the datatype \datatype{poly} as \datatype{array (Natural range  <>) of cmplx.Complex}.  Polynomials are implemented as an array of coefficients where the index in the array represents the exponent of the independent variable.  The index range starts from 0 and extends to the order of the polynomial.  This package contains operations on polynomials with complex number coefficients and independent variable.

\subsection{Basic Operations}
The basic binary operations on polynomials, addition (`+'), subtraction (`-'), and multiplication (`*') are implemented and assigned to the operators.  Unary negation (`-') is implemented and assigned to the `-' operator.  Multiplication of a polynomial by a scalar is implemented and assigned to the `*' operator for both scalar first and scalar last.

Division is based on the \function{poludiv()} implementation of synthetic division in \cite{NR-C}.  It divides two polynomials and returns a remainder and quotient.
\begin{align*}
  \frac{u}{v} = q, r
\end{align*}
\function{divide(u, v : poly; q : out poly; r : out poly)}
\begin{itemize}
  \item $u$ - The numerator for division.
  \item $v$ - The denominator for division.
  \item $q$ - The quotient result of the division.
  \item $r$ - The remainder from the division.
  \item This is a procedure, thus nothing is returned.
\end{itemize}

\subsection{Other Operations}

Evaluate a polynomial at a specific value of the independent variable.

\function{evaluate(p : poly; x : cmplx.Complex) return cmplx.Complex}
\begin{itemize}
  \item $p$ - The polynomial to evaluate.
  \item $x$ - The independent variable.
  \item Returns the value of the polynomial evaluated at $x$.
\end{itemize}

Eliminate any leading coefficients with a zero value.  For example $0x^3+x^2+3x+4$ gets trimmed to $x^2+3x+4$.

\function{trim(p : poly) return poly}
\begin{itemize}
  \item $p$ - The polynomial to trim.
  \item Returns the trimmed polynomial of order equal to or less than the original polynomial.
\end{itemize}

Determine the order of a polynomial.  That is the maximum index with a non-zero value.

\function{order(p : poly) return Natural}
\begin{itemize}
  \item $p$ - The polynomial to determine the order of.
  \item Returns the order of the polynomial.
\end{itemize}

\subsection{Utility}
For development or debugging purposes a simple print polynomial procedure is provided.

\function{print(p : poly; fore, aft, exp : Natural)}
\begin{itemize}
  \item $p$ - The polynomial to print.
  \item fore, aft, and exp - values passed in for floating point formatting.
  \item This is a procedure so no value is returned.  A representation of the polynomial is displayed on the default output.
\end{itemize}

\subsection{Calculus}
Integrals and derivatives of polynomials are fairly easy to generate.  So, functions are provided to take a polynomial and return the integral or the derivative.
\begin{align*}
  \int ax^n dx = a\frac{x^{n+1}}{n+1}+C
\end{align*}
The resulting polynomial for integration has order one greater than the original polynomial.

\function{integrate(p : poly; c : cmplx.Complex) return poly}
\begin{itemize}
  \item $p$ - The polynomial to integrate.
  \item $c$ - The constant term.
  \item Returns the integral of $p$.
\end{itemize}

\begin{align*}
  \frac{d}{dx}x^n = n x^{n-1}
\end{align*}
The resulting polynomial for differentiation has order one less than the original polynomial.

\function{derivative(p : poly) return poly}
\begin{itemize}
  \item $p$ - The polynomial to differentiate.
  \item Returns the derivative of the original polynomial.
\end{itemize}

\section{BBS.Numerical.polynomial\_real}
This is a generic package with a real type parameter, \datatype{F}.

The package defines the datatype \datatype{poly} as \datatype{array (Natural range  <>) of f'Base}.  Polynomials are implemented as an array of coefficients where the index in the array represents the exponent of the independent variable.  The index range starts from 0 and extends to the order of the polynomial.  This package contains operations on polynomials with real number coefficients and independent variable.

\subsection{Basic Operations}
The basic binary operations on polynomials, addition (`+'), subtraction (`-'), and multiplication (`*') are implemented and assigned to the operators.  Unary negation (`-') is implemented and assigned to the `-' operator.  Multiplication of a polynomial by a scalar is implemented and assigned to the `*' operator for both scalar first and scalar last.

Division is based on the \function{poludiv()} implementation of synthetic division in \cite{NR-C}.  It divides two polynomials and returns a remainder and quotient.
\begin{align*}
  \frac{u}{v} = q, r
\end{align*}
\function{divide(u, v : poly; q : out poly; r : out poly)}
\begin{itemize}
  \item $u$ - The numerator for division.
  \item $v$ - The denominator for division.
  \item $q$ - The quotient result of the division.
  \item $r$ - The remainder from the division.
  \item This is a procedure, thus nothing is returned.
\end{itemize}

\subsection{Other Operations}

Evaluate a polynomial at a specific value of the independent variable.

\function{evaluate(p : poly; x : f'Base) return f'Base}
\begin{itemize}
  \item $p$ - The polynomial to evaluate.
  \item $x$ - The independent variable.
  \item Returns the value of the polynomial evaluated at $x$.
\end{itemize}

Eliminate any leading coefficients with a zero value.  For example $0x^3+x^2+3x+4$ gets trimmed to $x^2+3x+4$.

\function{trim(p : poly) return poly}
\begin{itemize}
  \item $p$ - The polynomial to trim.
  \item Returns the trimmed polynomial of order equal to or less than the original polynomial.
\end{itemize}

Determine the order of a polynomial.  That is the maximum index with a non-zero value.

\function{order(p : poly) return Natural}
\begin{itemize}
  \item $p$ - The polynomial to determine the order of.
  \item Returns the order of the polynomial.
\end{itemize}

\subsection{Utility}
For development or debugging purposes a simple print polynomial procedure is provided.

\function{print(p : poly; fore, aft, exp : Natural)}
\begin{itemize}
  \item $p$ - The polynomial to print.
  \item fore, aft, and exp - values passed in for floating point formatting.
  \item This is a procedure so no value is returned.  A representation of the polynomial is displayed on the default output.
\end{itemize}

\subsection{Calculus}
Integrals and derivatives of polynomials are fairly easy to generate.  So, functions are provided to take a polynomial and return the integral or the derivative.
\begin{align*}
  \int ax^n dx = a\frac{x^{n+1}}{n+1}+C
\end{align*}
The resulting polynomial for integration has order one greater than the original polynomial.

\function{integrate(p : poly; c : f'Base) return poly}
\begin{itemize}
  \item $p$ - The polynomial to integrate.
  \item $c$ - The constant term.
  \item Returns the integral of $p$.
\end{itemize}

\begin{align*}
  \frac{d}{dx}x^n = n x^{n-1}
\end{align*}
The resulting polynomial for differentiation has order one less than the original polynomial.

\function{derivative(p : poly) return poly}
\begin{itemize}
  \item $p$ - The polynomial to differentiate.
  \item Returns the derivative of the original polynomial.
\end{itemize}

\section{BBS.Numerical.quaternion}
This is a generic package with a real type parameter, \datatype{F}.

Quaternions are an extension of complex numbers into three dimensions.  A quaternion $q$ is defined as follows:
\begin{align*}
  q=a+b\uvec{i}+c\uvec{j}+d\uvec{k}
\end{align*}
Where
\begin{align*}
  \uvec{i}^2+\uvec{j}^2+\uvec{k}^2=\uvec{i}\uvec{j}\uvec{k}=-1
\end{align*}

This package defines the datatype \datatype{quaternion} as a tagged record with fields $r$, $i$, $j$, and $k$, each of type \datatype{F'Base}.  This means that it is treated as an object and some of the functions can be called in object oriented fashion.

\subsection{Basic Operations}
The basic binary operations on polynomials, addition (`+'), subtraction (`-'), multiplication (`*'), and division (`/') are implemented and assigned to the operators.  Multiplication of a polynomial by a scalar is implemented and assigned to the `*' operator for both scalar first and scalar last.  Note that with quaternions, multiplication is not necessarily commutative.  That is, in general $q_1 q_2 \neq q_2 q_1$.

\subsection{Other Operations}

Compute the magnitude of a quaternion (similar to absolute value) using $|q| = \sqrt{a^2+b^2+c^2+d^2}$.  Note that overflow is possible if any of $a$, $b$, $c$, $d$ are greater than the square root of the maximum value of \datatype{F'Base}.

\function{magnitude(self : in quaternion) return f'Base}
\begin{itemize}
  \item $self$ - The quaternion to have its magnitude returned.
  \item Returns the magnitude of $self$.
\end{itemize}

Scale a quaternion to have a magnitude of 1 (a unit vector).  Since the magnitude is computed to be used as a scale factor, the same comments about overflow apply here.

\function{normalize(self : in quaternion) return quaternion}
\begin{itemize}
  \item $self$ - The quaternion to be scaled.
  \item Returns a unit quaternion with the same direction as $self$.
\end{itemize}

\section{BBS.Numerical.random}
This is not a generic package.

\cite{MT19937}
\section{BBS.Numerical.regression}
This is a generic package with a real type parameter, \datatype{F}.

\section{BBS.Numerical.roots\_complex}
This is a generic package with a complex package parameter, \datatype{cmplx}.  This has datatypes \datatype{cmplx.Complex} and \datatype{cmplx.Real}.

\section{BBS.Numerical.roots\_real}
This is a generic package with a real type parameter, \datatype{F}.

\section{BBS.Numerical.statistics}
This is a generic package with a real type parameter, \datatype{F}.

\section{BBS.Numerical.vector}
This is a generic package with a real type parameter, \datatype{F}.

\nocite{NA3rd}
\bibliographystyle{plain}
\bibliography{Numerical.bib}

%\printbibliography

\end{document}

